'I. INDICIA REPRESENTATIVE OF A RANK CORRESPONDS TO NUMERICAL
'VALUE ASSIGNED TO EACH CARD

'The game of the present invention utilizes cards or electronic
'representations thereof. The dealer could deal the game of the
'present invention from a single deck, or from multiple decks.
'Additionally, each deck may have a conventional constitution
'of fifty-two cards, a supplemented constitution of more than
'fifty-two cards, or a modified constitution of fewer than
'fifty-two cards.

'All embodiments of the game of the present invention are
'subject to a user-defined set of game rules. Each user-defined
'set of game rules does specify providing at least one deck of
'cards, so that each card in said at least one deck of cards
'bears indicia representative of a rank selected from a group
'of ranks consisting of ace, two, three, four, five, six,
'seven, eight, nine, ten, jack, queen, king, and joker, so that
'any card that bears indicia representative of a rank selected
'from a group of ranks consisting of ace, two, three, four,
'five, six, seven, eight, nine, ten, jack, queen, and king also
'bears indicia representative of a suit selected from a group
'of suits consisting of spades, hearts, clubs, and diamonds,
'and so that each deck of the at least one deck of cards
'consists of the same complement of cards and thereby has the
'same deck composition. 

'Each user-defined set of game rules does specify assigning a
'value to each card in said at least one deck of cards in
'accordance with the following set of conditional steps.

'If any card bears indicia representative of a rank of ace,
'then assign a numerical value selected from a group consisting
'of one point and fourteen points to said any card in
'accordance with the following set of rules. If any hand
'includes at least one ace, and if one ace can be assigned a
'value of fourteen points without causing the hand total of
'said any hand to exceed twenty-seven points, then select
'fourteen points as the value assigned to one ace in said any
'hand, and select one point as the value assigned to each of
'any additional aces in said any hand. If any hand includes at
'least one ace, and if one ace can not be assigned a value of
'fourteen points without causing the hand total of said any
'hand to exceed twenty-seven points, then select one point as
'the value assigned to each ace in said any hand.

'If any card bears indicia representative of a rank selected
'from a group of ranks consisting of two, three, four, five,
'six, seven, eight, nine, and ten, then assign to said any card
'a numerical value of a face value number of points to said any
'card. If any card bears indicia representative of a rank of
'jack, then assign a numerical value of eleven points to said
'any card. If any card bears indicia representative of a rank
'of queen, then assign a numerical value of twelve points to
'said any card. If any card bears indicia representative of a
'rank of king, then assign a numerical value of thirteen points
'to said any card.

'If any card bears indicia representative of a rank of joker,
'then assign to said any card a numerical value selected from a
'group of numerical values consisting of a numerical value of
'zero points, and a numerical value of any number of points
'required to make a hand total of twenty-seven points.

'II. USER-DEFINED SUBSET OF GAME RULES

'Go ahead and start the BIGS906 software application. After the
'BIGS906 software application dimensions arrays, the BIGS906
'software application displays some introductory remarks. Go
'ahead and read those. After displaying some introductory
'remarks, the BIGS906 software application begins a series of
'prompts for user input. Amongst other things, the prompts for
'user input enable the user to enter a user-defined subset of
'game rules. The subset of game rules specifies the composition
'of each deck, and the number of decks in the stack. If each
'deck includes at least one joker, then the subset of game
'rules also includes a rule specifying the point value assigned
'to the at least one joker.

'III. USER-DEFINABLE DECK COMPOSITION

'The BIGS906 software application begins the series of prompts
'by prompting the user to press 'y' and enter for a standard
'deck composition. If the user does press 'y' and enter, then
'the user-defined deck composition will be the standard deck
'composition. The standard deck composition is a supplemented
'complement of fifty-four cards consisting of thirteen ranks of
'each of four French suits plus two jokers.

'If the user presses some other combination of keys and the
''enter' key or simply presses the 'enter' key in response to
'the above-described prompt, then the BIGS906 software
'application provides a series of prompts for user input as a
'software means for enabling the user to input the number of
'cards assigned each of the supported numerical values. The
'complement of cards becomes the user-defined deck composition.

'The BIGS906 software application begins the series of prompts
'for user input with a prompt for the user to input the number
'of cards assigned a value of zero points.

'After the user inputs the number of cards assigned a value of
'zero points, the BIGS906 software application continues the
'series of prompts for user input with a prompt for the user to
'input the number of cards assigned a value selected from a
'group consisting of one point and fourteen points.

'After the user inputs the number of cards assigned a value
'selected from a group consisting of one point and fourteen
'points, the BIGS906 software application continues with a
'series of prompts for the user to input the number of cards
'assigned each individual numerical value selected respectively
'from a group of numerical values consisting of two points,
'three points, four points, five points, six points, seven
'points, eight points, nine points, ten points, eleven points,
'twelve points, and thirteen points.

'If the user inputs zero as the number of cards assigned a
'value of zero points, then after the user inputs the number of
'cards assigned a value of thirteen points, the BIGS906
'software application prompts the user to input the number of
'cards assigned a value of any number of points required to
'make a hand total of twenty-seven points.

'If the user inputs a non-zero number as the number of cards
'assigned a value of zero points, then after the user inputs
'the number of cards assigned a value of thirteen points, the
'BIGS906 software application does not prompt the user to input
'the number of cards assigned a value of any number of points
'required to make a hand total of twenty-seven points.

'Accordingly, the BIGS906 software application supports fifteen
'numerical values. However, the user can only include a maximum
'of fourteen of the fifteen supported numerical values in a
'user-defined deck composition. Any one of the two numerical
'values selected from a group consisting of zero points, and
'any number of points required to make a hand total of twenty-
'seven points, can be assigned to one or more Jokers. The
'remaining thirteen numerical values correspond to the thirteen
'non-Joker ranks.

'IV. USER-DEFINABLE NUMBER OF DECKS

'After the user responds to the above-described prompts, the
'BIGS906 software application prompts the user to input the
'number of decks. The user can input any number of decks.
'However, if the user intends to use a game simulator selected
'from a group consisting of the BIGS908 software application
'and the BIGS988 software application to simulate a game, then
'I suggest the user limit the total number of cards in the
'virtual stack to no more than four-hundred-eighty-six cards.
'The BIGS908 software application, and the BIGS988 software
'application are a game simulators compatible with the data
'output by the BIGS906 software application. Both game
'simulators are preset to accommodate a virtual stack
'consisting of up to four-hundred and sixty-eight cards.

'V. HOW TO ENABLE GAME SIMULATORS TO ACCOMMODATE A LARGER STACK

'If it is necessary that the virtual stack consist of more than
'four-hundred sixty-eight cards, then read the comments added
'by the applicant to the source code of each game simulator to
'find an explanation of how to modify the source code so as to
'enable the game simulator to accommodate a larger virtual
'stack.

'VI. SUGGESTED FILE NAMING PROTOCOL

'After the user responds to the series of above-described
'prompts, the BIGS906 software application prompts the user to
'enter the 'folder/file name prefix' to be used to store
'application output. Here the BIGS906 software application is
'prompting the user to enter one of three parts of a file name.
'The three parts are a file name prefix, a file name suffix,
'and a file name extension.

'The file name prefix is a user-definable name. The file name
'prefix is common to each file of a set of files saved as
'application output.

'The file name suffix consists of a single letter. The BIGS906
'software application adds a file name suffix to the file name
'prefix of each file of the set of files saved as application
'output. Each file name suffix is unique to each file of the
'set of files saved as application output. Accordingly, the
'combination of the file name prefix and the file name suffix
'enables users and other applications in the BIGS collection to
'identify the specific contents of each file of the set of
'files.

'The file name extension consists of a period followed by a set
'of three characters. The file name extension indicates the

'type of file. The two types of file that are saved by the
'BIGS906 software application are text file and data file. If
'the type of file is a text file, then .txt is the file name
'extension. If the type of file is a data file, then .dat is
'the file name extension.

'There is a need for an intelligent way of naming files for
'later reference. I suggest making a folder named 906docs to
'hold the various files the BIGS906 software application will
'save. I suggest putting the folder named 906docs within the
'same folder containing the BIGS906 software application. Doing
'so makes saving a set of databases built by the BIGS906
'software application easier than it might otherwise be. I
'suggest making the file name prefix some combination of
'characters that will remind the user later of the user-defined
'subset of game rules used by the BIGS906 software application
'to build the databases of dealer-finish probabilities saved to
'a set of data files by the BIGS906 software application.

'VII. EXAMPLES OF THE SUGGESTED FILE NAMING PROTOCOL

'These paragraphs provide the user with some examples to
'follow.If the user-defined number of decks in the virtual
'stack is four, if the user-defined composition of each deck is
'the standard deck composition, and if each joker has a value
'of zero points, then I suggest using 'J4d' as the file name
'prefix. If the user follows my suggestions, then the user will
'enter 906docs/J4d when prompted to enter the folder/file name
'prefix to be used to store application output.

'If the user-defined number of decks of cards is two, if the
'user-defined composition of each deck in the virtual stack is
'the standard deck composition, and if each joker has a value
'of any number of points required to make a hand total of
'twenty-seven points, then I suggest using 'wc2d' as the file
'name prefix. If the user follows my suggestions, then the user
'will enter 906docs/wc2d when prompted to enter the folder/file
'name prefix to be used to store application output.

'If the number of decks in the virtual stack is five, and if
'the composition of each deck is thirteen ranks of four French
'suits and no jokers, then I suggest using '5d' as the file
'name prefix. If the user follows my suggestions, then the user
'will enter 906docs/5d when prompted to enter the folder/file
'name prefix to be used to store application output.

'VIII. TEXT FILE CONTAINING A RECORD OF USER-INPUT

'After the user enters a 'folder/file name prefix', the BIGS906
'software application saves a meaningful selection of the text
'to a text file named with an 'i' character as the file name
'suffix. The meaningful selection of text consists of the text
'of the prompts for user input and the user responses that
'appeared in the application window while the BIGS906 software
'application performed its' functions. The user can open this
'file and view its' contents. The contents are intended to
'serve as a record giving the user a summary of the user
'responses to prompts for user input made by the BIGS906
'software application.

'IX. DEALER-FINISH PROBABILITIES

'A dealer-finish probability is the probability that the
'dealer's complete hand will have a particular hand total given
'a particular strategy for the play of the dealer's hand, and
'given all combinations of card ranks that are possible for a
'set of hands consisting of the player's initial hand and the
'dealer's complete hand.  A subset of dealer-finish-
'probabilities consists of a dealer-finish probability for each
'of a set of hand totals that are possible for the dealer's
'complete hand. A set of dealer-finish probabilities consists
'of a subset of dealer-finish probabilities for each of the
'twenty-seven-supported strategies for the play of the dealer's
'hand. The database of dealer-finish probabilities consists of
'the set of dealer-finish probabilities for each of the
'combinations of card ranks that could be the combination of
'card ranks assigned to the cards removed from the stack and
'dealt face up to form a set of hands consisting of the
'player's initial hand and the dealer's initial hand.

'After the BIGS906 software application saves the text file
'containing a meaningful selection of the text that appeared in
'the application window while the user input the user-definable
'subset of game rules, the BIGS906 software application builds
'a set of databases of dealer-finish probabilities. The set of
'databases of dealer-finish probabilities consists of three
'databases. The first database is built for the set of hands
'consisting of the player's initial hand and the dealer's
'initial hand. The second database is built for the set of
'hands consisting of the player's post-split-initial hand and
'the dealer's initial hand wherein: The value of variable pc1
'is greater than or equal to the value of variable pc2. The
'third database is built for the set of hands consisting of the
'player's post-split-initial hand and the dealer's initial hand
'wherein: The value of variable pc2 is greater than or equal to
'the value of variable pc1.

'X. FUNCTIONS OF THE NESTED-FOR-NEXT LOOP OF THE MAIN ROUTINE

'The user-defined set of game rules assigns a combination of
'card ranks to the cards in the set of hands consisting of the
'player's initial hand and the dealer's initial hand. Thousands
'of combinations of card ranks are possible. For each unique
'combination of card ranks, the BIGS906 software application
'calculates a set of dealer-finish probabilities.

'The values given to variables named pc1 and pc2 correspond to
'the ranks of the first two cards of a player's hand. The
'values given to variables named dc1 and dc2 correspond to the
'ranks of the first two cards of a dealer's hand. A value of
'zero corresponds to the rank of joker. A value of one
'corresponds to a rank of ace. Values two through ten
'correspond to the ranks of two through ten respectively. A
'value of eleven corresponds to the rank of jack. A value of
'twelve corresponds to the rank of queen. A value of thirteen
'corresponds to the rank of king.

'The BIGS906 software application performs a main routine. The
'main routine uses variables k, l, m, and e in a nested-for-
'next loop to step through each of the eleven-thousand-twenty-
'five unique combinations of card ranks that are possible for
'the combination of cards in the set of hands consisting of the
'player's initial hand and the dealer's initial hand.

'The main routine uses variables k and l to step through each
'of the one-hundred-five unique combinations of card ranks that
'are possible for the two cards in the player's initial hand.
'If the player's initial hand is a initial hand, then the
'values of pc1 and pc2 correspond respectively to the values of
'variables k and l.

'If the player's hand is the player's initial hand, and if the
'value of pc1 is not equal to the value of pc2, then the order
'of the cards in the hand produces duplicate combinations of
'card ranks. For example, the combination of card ranks
'assigned to an ace and a jack, is the same as the combination
'of card ranks assigned to a jack and an ace. The duplicate
'combinations of card ranks produce duplicate sets of dealer-
'finish probabilities. Storing the sets of dealer-finish
'probabilities one time requires less memory than does storing
'the sets of dealer-finish probabilities two times. Calculating
'the sets of dealer-finish probabilities one time is twice as
'fast as calculating the sets of dealer-finish probabilities
'two times. For that reason, the main routine eliminates every
'combination of card ranks wherein: The value of variable pc1
'is greater than the value of variable pc2. After eliminating
'these combinations of card ranks, there remains one-hundred
'five unique combinations of card ranks that are possible for
'the two cards in the player's initial hand.

'If the player's hand is the player's initial hand, and if the
'value of pc1 is equal to the value of pc2, then the main
'routine steps through each of the card ranks that are possible
'for the second card of the player's post-split-initial hand.
'Variable pc1 provides a memory element wherein: The BIGS906
'software application stores the card rank assigned to the
'first card of the player's post-split-initial hand, and
'wherein: The BIGS906 software application stores the card rank
'assigned to the other card of the original pair. Variable pc2
'provides a memory element wherein: The BIGS906 software
'application stores the card rank assigned to the second card
'of the player's post-split-initial hand.

'If the player's hand is the player's post-split-initial hand,
'and if the value of pc1 is not equal to the value of pc2, then
'the order of the cards in the hand produces duplicate
'combinations of card ranks. For example, the combination of
'card ranks assigned to an ace and a jack, is the same as the
'combination of card ranks assigned to a jack and an ace.
'However, the card rank assigned to the first card of the
'player's post-split-initial hand is also the card rank
'assigned to the other card of the original pair. For that
'reason, the duplicate combinations of card ranks produce
'different sets of dealer-finish probabilities. For that
'reason, the main routine steps through every combination of
'card ranks that is possible for the player's post-split-
'initial hand.

'The BIGS906 software application sorts every combination of
'card ranks that is possible for the player's post-split-
'initial hand into at least one of two groups. The first group
'consists of one-hundred-five unique combinations of card ranks
'wherein: The value of pc1 is equal to or greater than the
'value of pc2. The second group consists of one-hundred-five
'unique combinations of card ranks wherein: The value of pc1 is
'less than or equal to the value of pc2.

'The main routine uses variables m and e to step through each
'of the one-hundred-five unique combinations of card ranks that
'are possible for the two cards in the dealer's initial hand.
'The values of dc1 and dc2 correspond respectively to the
'values of variables m and e.

'If the value of dc1 is not equal to the value of dc2, then the
'order of the cards in the dealer's initial hand produces
'duplicate combinations of card ranks. For example, the
'combination of card ranks assigned to a two and a queen, is
'the same as the combination of card ranks assigned to a queen
'and a two. The duplicate combinations of card ranks produce
'duplicate sets of dealer-finish probabilities. Storing the
'sets of dealer-finish probabilities one time requires less
'memory than does storing the sets of dealer-finish
'probabilities two times. Calculating the sets of dealer-finish
'probabilities one time is twice as fast as calculating the
'sets of dealer-finish probabilities two times. For that
'reason, the main routine eliminates every combination of card
'ranks wherein: The value of variable dc1 is greater than the
'value of variable dc2. After eliminating these combinations of
'card ranks, there remains one-hundred-five unique combinations
'of card ranks that are possible for the two cards in the
'dealer's initial hand.

'The product of one-hundred-five unique combinations of card
'ranks multiplied by one-hundred-five unique combinations of
'card ranks is eleven-thousand-twenty-five unique combinations
'of card ranks. For that reason, eleven-thousand-twenty-five
'unique combinations of card ranks are possible for the
'combination of cards in the set of hands consisting of the

'player's initial hand and the dealer's initial hand. Eleven-
'thousand-twenty-five unique combinations of card ranks are
'possible for the combinations of cards in the set of hands
'consisting of the dealer's initial hand and the player's post-
'split-initial hand wherein: The value of pc1 is equal to or
'greater than the value of pc2. Eleven-thousand-twenty-five
'unique combinations of card ranks are possible for the
'combinations of cards in the set of hands consisting of the
'dealer's initial hand and the player's post-split-initial hand
'wherein: The value of pc1 is less than or equal to the value
'of pc2.

'XI. FUNCTION OF VARIABLES pn% AND dn%

'Variable pn% provides a memory element wherein: The BIGS906
'software application stores an integer. The integer identifies
'the combination of card ranks assigned to the cards in the
'player's initial hand.

'The BIGS906 software application uses an equation to calculate
'the value of pn%. If the value of pc1 is less than or equal to
'the value of pc2, then the equation is pn% = pc1 / 2 * (27 -
'pc1) + pc2. If the value of pc1 is equal to or greater than
'the value of pc2, then the equation is pn% = pc2 / 2 * (27 ?
'pc2) + pc1.

'Variable dn% provides a memory element wherein: The BIGS906
'software application stores an integer. The integer identifies
'the combination of card ranks assigned to the two cards in the
'dealer's initial hand.

'The BIGS906 software application uses an equation to calculate
'the value of dn%. The equation is dn% = dc1 / 2 * (27 - dc1) +
'dc2.

'If the value of pc1 is less than or equal to the value of pc2,
'then the one-hundred-five values that are possible for pn%
'correspond to the following values for pc1 and pc2. If the
'value of pc2 is equal to or greater than the value of pc1,
'then the one-hundred-five values that are possible for pn%
'correspond to the following values for pc2 and pc1. The one-
'hundred-five values that are possible for dn% correspond to
'the following values for dc1 and dc2.

'0 = 0 and 0     35 = 2 and 10   70 = 6 and 7
'1 = 0 and 1     36 = 2 and 11   71 = 6 and 8
'2 = 0 and 2     37 = 2 and 12   72 = 6 and 9
'3 = 0 and 3     38 = 2 and 13   73 = 6 and 10
'4 = 0 and 4     39 = 3 and 3    74 = 6 and 11
'5 = 0 and 5     40 = 3 and 4    75 = 6 and 12
'6 = 0 and 6     41 = 3 and 5    76 = 6 and 13
'7 = 0 and 7     42 = 3 and 6    77 = 7 and 7
'8 = 0 and 8     43 = 3 and 7    78 = 7 and 8
'9 = 0 and 9     44 = 3 and 8    79 = 7 and 9
'10 = 0 and 10   45 = 3 and 9    80 = 7 and 10
'11 = 0 and 11   46 = 3 and 10   81 = 7 and 11
'12 = 0 and 12   47 = 3 and 11   82 = 7 and 12
'13 = 0 and 13   48 = 3 and 12   83 = 7 and 13
'14 = 1 and 1    49 = 3 and 13   84 = 8 and 8
'15 = 1 and 2    50 = 4 and 4    85 = 8 and 9
'16 = 1 and 3    51 = 4 and 5    86 = 8 and 10
'17 = 1 and 4    52 = 4 and 6    87 = 8 and 11
'18 = 1 and 5    53 = 4 and 7    88 = 8 and 12
'19 = 1 and 6    54 = 4 and 8    89 = 8 and 13
'20 = 1 and 7    55 = 4 and 9    90 = 9 and 9
'21 = 1 and 8    56 = 4 and 10   91 = 9 and 10
'22 = 1 and 9    57 = 4 and 11   92 = 9 and 11
'23 = 1 and 10   58 = 4 and 12   93 = 9 and 12
'24 = 1 and 11   59 = 4 and 13   94 = 9 and 13
'25 = 1 and 12   60 = 5 and 5    95 = 10 and 10
'26 = 1 and 13   61 = 5 and 6    96 = 10 and 11
'27 = 2 and 2    62 = 5 and 7    97 = 10 and 12
'28 = 2 and 3    63 = 5 and 8    98 = 10 and 13
'29 = 2 and 4    64 = 5 and 9    99 = 11 and 11
'30 = 2 and 5    65 = 5 and 10   100 = 11 and 12
'31 = 2 and 6    66 = 5 and 11   101 = 11 and 13
'32 = 2 and 7    67 = 5 and 12   102 = 12 and 12
'33 = 2 and 8    68 = 5 and 13   103 = 12 and 13
'34 = 2 and 9    69 = 6 and 6    104 = 13 and 13

'XII. FUNCTIONS VARIABLE deck% AND ARRAY DIMENSIONS card(28)
'AND mc(48)

'Array dimension card(28) provides memory elements wherein: The
'BIGS906 software application stores the number of cards of
'each rank in the user-definable deck composition. Variable
'deck% provides a memory element wherein: The BIGS906 software
'application stores the user-definable number of decks in the
'virtual stack. Array dimension mc(48) provides memory elements
'wherein: The BIGS906 software application stores the current
'number of cards of each rank that are remaining in the virtual
'stack.

'XIII. FUNCTIONS OF THE MAIN ROUTINE

'For each of the eleven-thousand-twenty-five combinations of
'point values that the rules might assign to the combination of
'playing cards in the set of hands consisting of the player's
'initial hand and the dealer's initial hand, the main routine
'does all of the following. The main routine sets the current
'number of playing cards of each rank that are remaining in the
'virtual stack equal to the product of the number of cards of
'each rank in the user-definable  deck composition multiplied
'by the user-definable number of decks in the virtual stack.

'If the main routine is finding the set of dealer-finish
'probabilities given the combination of card ranks assigned to
'the cards in the set of hands consisting of the player's
'initial hand and the dealer's initial hand, then the main
'routine mathematically removes from the virtual stack each of
'the cards in the set of hands consisting of the player's
'initial hand and the dealer's  initial hand. The main routine
'does so by subtracting one from the value of each of the
'corresponding memory elements in array dimension mc(48).

'If the main routine is finding the set of dealer-finish
'probabilities given the combination of card ranks assigned to

'the cards in the set of hands consisting of the player's post-
'split-initial hand and the dealer's initial hand, then the
'main routine mathematically removes from the virtual stack
'each of the cards in the set of hands consisting of the
'player's post-split-initial hand and the dealer's initial
'hand.  The main routine mathematically removes from the
'virtual stack the other card of the original pair. The main
'routine does so by subtracting one from the corresponding
'memory elements in array dimension mc(48).

'XIV. HARD AND SOFT

'There are two basic types of hands. If a hand includes at
'least one ace and the dealer can count one ace as fourteen
'points without causing the sum of the point values assigned to
'the cards in the hand to exceed twenty-seven points, then the
'hand is a "soft" hand. Otherwise, the hand is a "hard" hand.
'If the sum of the point values assigned to the cards in a hard
'hand does exceed twenty-seven points, then the holder of the
'hand does bust. However, if the sum of the point values
'assigned to the cards in a soft hand does exceed twenty-seven
'points, then the holder of the hand does not bust. Instead,
'the value of the ace counted as fourteen points changes to one
'point, and the soft hand becomes a hard hand.

'A hand total is equal to the sum of the point values assigned
'to the cards in a hand. There are two basic types of hand
'totals. A soft total is the hand total of a soft hand. For
'example, ?soft twenty-five? is the soft total of a soft hand
'consisting of an ace of diamonds and a jack of diamonds. A
'hard total is the hand total of a hard hand. For example,
'?hard twenty-three? is the hard total of a hard hand
'consisting of an ace of spades, a nine of diamonds, and a king
'of clubs.

'XV. A STRATEGY FOR THE PLAY OF THE DEALER'S HAND

'A strategy for the play of the dealer's hand specifies a
'target-numerical sum for the play of the dealer's hard hands
'and a target-numerical sum for the play of the dealer's soft
'hands. To use any given strategy for the play of the dealer's
'hand to make decisions on how to play the dealer's hand, the
'dealer does the following. If the dealer's hand total is less
'than the target-numerical sum specified for the type of hand
'the dealer has, then the dealer hits. If the dealer's hand
'total is at least equal to the target-numerical sum specified
'for the type of hand the dealer has, then the dealer stands.

'The BIGS906 software application supports a set of twenty-
'seven of the possible strategies for the play of the dealer's
'hand. Each of the twenty-seven-supported strategies for the
'play of the dealer's initial hand specifies a unique
'combination of a target-numerical sum for the dealer's hard
'hands and a target-numerical sum for the dealer's soft hands.

'Because the dealer cannot bust while holding a soft hand, it
'does not make sense for the user to specify a target-numerical
'sum for the dealer's soft hands that is less than the target-
'numerical sum specified for the dealer's hard hands. In fact,
'the strategies for the play of the dealer's hand that yield
'higher-house edges tend to be those strategies that specify a
'target-numerical sum for the dealer's soft hands that is
'higher than the target-numerical sum specified for the
'dealer's hard hands. For that reason, none of the twenty-
'seven-supported strategies for the play of the dealer's hand
'specifies a target-numerical sum for the play of the dealer's
'soft hands that is lower than the target-numerical sum
'specified for the play of the dealer's hard hands.

'Each of the set of twenty-seven-supported strategies for the
'play of the dealer's hand specify one of a group of twenty-
'seven combinations of target-numerical sums for the play of
'the dealer's hand consisting of the following hard total/soft
'total combinations. 19/A5, 19/A6, 19/A7, 19/A8, 19/A9, 19/AT,
'19/AJ, 20/A6, 20/A7, 20/A8, 20/A9, 20/AT, 20/AJ, 21/A7, 21/A8,
'21/A9, 21/AT, 21/AJ, 22/A8, 22/A9, 22/AT, 22/AJ, 23/A9, 23/AT,
'23/AJ, 24/AT, and 24/AJ.

'It is necessary to calculate the dealer-finish probabilities
'for all twenty-seven of the supported strategies for the play
'of the dealer's hand so that the BIGS907 software application
'can later enable users to select any one of the twenty-seven-
'supported strategies for the play of the dealer's hand to be
'the strategy for the play of the dealer's hand specified by
'the user-defined set of game rules.

'XVI. THE SET OF POSSIBLE HAND TOTALS FOR THE DEALER'S COMPLETE
'HAND

'The target-numerical sum specified for the play of the
'dealer's hard hands determines the set of hand totals that is
'possible for the dealer's complete hand. The target-numerical
'sum specified for the play of the dealer's soft hands is
'always equal to or greater than the target-numerical sum
'specified for the play of the dealer's hard hands. For that
'reason, the lowest hand total that is possible for the
'dealer's complete hand is equal to the target-numerical sum
'specified for the play of the dealer's hard hands. As long as
'the dealer has a soft hand, the dealer cannot bust with more
'than twenty-seven points. The highest hard total that the
'dealer can draw to is one point less than the target-numerical
'sum specified for the play of the dealer's hard hands. If the
'dealer does so, then the highest number of points that the
'rules could possibly assign to a card drawn by the dealer is
'thirteen points. For that reason, the highest hand total that
'is possible for the dealer's complete hand is twelve points
'more than the target-numerical sum specified for the play of
'the dealer's hard hands.

'The predetermined strategy for the play of the dealer's hand
'does specify a target-numerical sum for the dealer's hard
'hands selected from a set of supported-target-numerical sums
'consisting of nineteen points, twenty points, twenty-one
'points, twenty-two points, twenty-three points, and twenty-
'four points. Accordingly, the sets of hand totals that are
'possible for the dealer's complete hand are nineteen through
'thirty-one points, twenty through thirty-two points, twenty-
'one through thirty-three points, twenty-two through thirty-
'four points, twenty-three through thirty-five points, and
'twenty-four through thirty-six points respectively.

'XVII. FUNCTIONS OF VARIABLES g, h, AND I%

'Variable g provides a memory element wherein: The BIGS906
'software application stores a value for the target-numerical
'sum given for the play of the dealer's hard hands. Variable h
'provides a memory element wherein: The BIGS906 software
'application stores a value for the target-numerical sum given
'for the play of the dealer's soft hands. Variable I% provides
'a memory element wherein: The BIGS906 software application
'stores the value of a number representing an ordinal number
'assigned by the main routine to the strategy for the play of
'the dealer's hand.

'Numbers assigned by the main routine to each strategy for the
'play of the dealer's hand and the corresponding set of target
'numerical sums are as follows.

' 1 = 19/A5          10 = 20/A8          19 = 22/A8
' 2 = 19/A6          11 = 20/A9          20 = 22/A9
' 3 = 19/A7          12 = 20/AT          21 = 22/AT
' 4 = 19/A8          13 = 20/AJ          22 = 22/AJ
' 5 = 19/A9          14 = 21/A7          23 = 23/A9
' 6 = 19/AT          15 = 21/A8          24 = 23/AT
' 7 = 19/AJ          16 = 21/A9          25 = 23/AJ
' 8 = 20/A6          17 = 21/AT          26 = 24/AT
' 9 = 20/A7          18 = 21/AJ          27 = 24/AJ

'The main routine uses variables g, h, and I% in nested-for-
'next loops to step through each of twenty-seven-supported
'strategies for the play of the dealer's hand.

'XVIII. FUNCTIONS OF SUBROUTINE 666

'The main routine sends values stored in the above-described
'variables and array dimensions to the 666 subroutine. Each
'time the main routine calls the 666 subroutine, the 666
'subroutine calculates a subset of dealer-finish probabilities
'given one of the eleven-thousand-twenty-five combinations of
'card ranks that are possible for the set of hands consisting
'of the player's initial hand and the dealer's initial hand,
'and given one of the twenty-seven-supported strategies for the
'play of the dealer's hand. The main routine does so given the
'user-definable subset of rules input by the user in response
'to prompts for user input made by the BIGS906 software
'application. The following is a description of the functions
'of the various variables and arrays found in the 666
'subroutine.

'XIX. FUNCTIONS OF VARIABLES pc1, pc2, dc1, dc2, r, s, t, u, v,
'w, o, AND jo27%

'The dealer's current hand does consist of the two cards in the
'dealer's initial hand and any combination of cards that the
'dealer might draw while the dealer forms the dealer's complete
'hand. Subroutine 666 relies upon the structure created by
'nested-for-next loops to step through most of the combinations
'of card ranks that are possible for the dealer's current hand.

'The values given to variables named pc1 and pc2 correspond to
'the ranks of the first two cards of a player's hand. The
'values given to variables named dc1 and dc2 correspond to the
'ranks of the first two cards of a dealer's hand. The values
'given to variables r, s, t, u, v, w, and o correspond to the
'ranks of the third, fourth, fifth, sixth, seventh, eighth, and
'ninth cards that the dealer might draw to the dealer's current
'hand. A value of zero corresponds to the rank of joker. A
'value of one corresponds to a rank of ace. Values two through
'ten correspond to the ranks of two through ten respectively. A
'value of eleven corresponds to the rank of jack. A value of
'twelve corresponds to the rank of queen. A value of thirteen
'corresponds to the rank of king.

'Variable jo27% provides a memory element wherein the BIGS906
'software application stores data about whether the user-
'defined subset of game rules includes a rule. The rule
'specifies that any hand that includes at least one joker has a
'value of twenty-seven points. If the user-defined subset of
'rules does include the rule, then any hand that includes at
'least one joker has a value of twenty-seven points. If the
'user-defined subset of game rules does not include the rule,
'then each joker has a value of zero points.

'XX. FUNCTIONS OF DIMENSIONED ARRAYS dadd(23), dp(23),
'dmult(23) AND djoke(23)

'Array dimension dadd(23) provides memory elements wherein the
'BIGS906 software application stores data about the numerical-
'sum value of the cards in the dealer's current hand. Array
'dimension dp(23) provides memory elements wherein the BIGS906
'software application stores data about the probability of the
'dealer drawing the combination of card ranks assigned to the
'cards in the dealer's current hand. Array dimension dmult(23)
'provides memory elements wherein the BIGS906 software
'application stores data about whether the dealer's current
'hand includes an ace. Array dimension djoke(23) provides
'memory elements wherein the BIGS906 software application
'stores data about whether the dealer's current hand includes a
'joker.

'XXI. FUNCTIONS OF DIMENSIONED ARRAY df(27, 14)

'The two dimensions of array df(27, 14) provide memory elements
'wherein: The BIGS906 software application temporarily stores
'the set of dealer-finish probabilities for a single one of the
'eleven-thousand-twenty-five unique combinations of card ranks
'that are possible for the set of hands consisting of the
'player's initial hand and the dealer's initial hand. The
'BIGS906 software application uses memory-elements one through
'twenty-seven of the first dimension of array df(27, 14) to
'sort dealer-finish probabilities according to the twenty-
'seven-supported strategies for the play of the dealer's hand.
'The BIGS906 software application uses memory-elements zero
'through twelve of the second dimension of array df(27, 14) to
'sort dealer-finish probabilities according to the frequency of
'occurrence of each of thirteen-point totals that could be the
'dealer's hand total. The BIGS906 software application uses
'memory-element thirteen of the second dimension of array df
'(27, 14) to sort dealer-finish probabilities according to the
'sum of the frequency of occurrence of each of the thirteen-
'point totals that could be the dealer's hand total. The
'BIGS906 software application uses memory-element fourteen of
'the second dimension of array df(27, 14) to sort dealer-finish
'probabilities according to the frequency of the occurrence of
'a dealer bust.

'XXII. FUNCTIONS OF DIMENSIONED ARRAYS dfr(104, 104, 27, 14),
'dfar(104, 104, 27, 14) AND dsar(104, 104, 27, 14)

'The four dimensions of array dbr(104, 104, 27, 14) provide
'memory elements wherein: The BIGS906 software application
'stores the database of dealer-finish probabilities calculated
'for the eleven-thousand-twenty-five unique combinations of
'card ranks that are possible for the set of hands consisting
'of the player's initial hand and the dealer's initial hand.
'The four dimensions of array dfar(104, 104, 27, 14) provide
'memory elements wherein: The BIGS906 software application
'stores the database of dealer-finish probabilities calculated
'for the eleven-thousand-twenty-five unique combinations of
'card ranks that are possible for the set of hands consisting
'of the player's post-split-initial hand and the dealer's
'initial hand wherein: The value of variable pc1 is equal to or
'greater than the value of variable pc2. The four dimensions of
'array dsar(104, 104, 27, 14) provide memory elements wherein:
'The BIGS906 software application stores the database of
'dealer-finish probabilities calculated for the eleven-
'thousand-twenty-five unique combinations of card ranks that
'are possible for the set of hands consisting of the player's
'post-split-initial hand and the dealer's initial hand wherein:
'The value of variable pc1 is less than or equal to the value
'of variable pc2.

'The BIGS906 software application uses memory-elements zero
'through one-hundred-four of the first dimension of array dfr
'(104, 104, 27, 14) to sort dealer-finish probabilities
'according to the one-hundred-five unique combinations of card
'ranks that are possible for the two cards in the player's
'initial hand. The BIGS906 software application uses memory-
'elements zero through one-hundred-four of the first dimension
'of array dfar(104, 104, 27, 14) to sort dealer-finish
'probabilities according to the one-hundred-five unique
'combinations of card ranks that are possible for the two cards
'in the player's post-split-initial hand wherein: The value of
'variable pc1 is equal to or greater than the value of variable
'pc2. The BIGS906 software application uses memory-elements
'zero through one-hundred-four of the first dimension of array
'dsar(104, 104, 27, 14) to sort dealer-finish probabilities
'according to the one-hundred-five unique combinations of card
'ranks that are possible for the two cards in the player's
'post-split-initial hand wherein: The value of variable pc1 is
'less than or equal to the value of variable pc2. The BIGS906
'software application uses memory-elements zero through one-
'hundred-four of the second dimension of each of the three
'above-described arrays to sort dealer-finish probabilities
'according to the one-hundred-five unique combinations of card
'ranks that are possible for the two cards in the dealer's
'initial hand. The BIGS906 software application uses memory-
'elements one through twenty-seven of the third dimension of
'each of the three-above-described arrays to sort dealer-finish
'probabilities according to the twenty-seven-supported
'strategies for the play of the dealer's hand. The BIGS906
'software application uses memory-elements zero through twelve
'of the fourth dimension of each of the three-above-described
'arrays to sort dealer-finish probabilities according to the
'frequency of occurrence of each of thirteen-point totals that
'could be the dealer's hand total. The BIGS906 software
'application uses memory-element thirteen of the fourth
'dimension of each of the three-above-described array to sort
'dealer-finish probabilities according to the sum of the
'frequency of occurrence of each of the thirteen-point totals
'that could be the dealer's hand total. The BIGS906 software
'application uses memory-element fourteen of the fourth
'dimension of each of the three-above-described arrays to sort
'dealer-finish probabilities according to the frequency of the
'occurrence of a dealer bust.

'XXIII. OUTPUT

'When the BIGS906 software application finishes finding the set
'of dealer-finish probabilities for one combination of card
'ranks, then the BIGS906 software application displays that
'combination of card ranks in a message printed on the
'application window. The BIGS906 software application uses
'numbers to represent ranks. The number zero represents the
'rank of joker. The number one represents the rank of ace. The
'numbers two through ten represent ranks two through ten
'respectively. The number eleven represents the rank of jack.
'The number twelve represents the rank of queen. The number
'thirteen represents the rank of king.

'After the BIGS906 software application finishes calculating
'the set of dealer-finish probabilities for all combinations of
'card ranks, the BIGS906 software application saves three data
'files. The data file named with an 'e' character as the file
'name suffix contains the database of dealer-finish
'probabilities calculated for the eleven-thousand-twenty-five
'unique combinations of card ranks that are possible for the
'set of hands consisting of the player's non-split initial hand
'and the dealer's initial hand. The data file named a 'f'
'character as the file name suffix, contains the database of
'dealer-finish probabilities for calculated for the eleven-
'thousand-twenty-five unique combinations of card ranks that
'are possible for the set of hands consisting of the player's
'post-split hand and the dealer's initial hand wherein: The
'value of variable pc1 is greater than or equal to the value of
'variable pc2. the data file named with a 'g' character as the
'file name suffix contains the database of dealer-finish
'probabilities calculated for the eleven-thousand-twenty-five
'unique combinations of card ranks that are possible for the
'set of hands consisting of the player's post-split hand and
'the dealer's initial hand wherein: The value of variable pc1
'is less than or equal to the value of variable pc2. These
'files are each just over 18 Megabytes in size.

'The good news is. The BIGS907 software application enable
'users to load into program memory the set of databases of
'player-finish probabilities and the user-defined subset of
'game rules saved to a set of data files by the BIGS903
'software application. The BIGS907 software application enables
'users to load into program memory a corresponding set of
'databases of dealer-finish probabilities saved to a set of
'data files by the BIGS906 software application. The BIGS907
'software application enable users to complete the user-defined
'set of game rules by adding any of nearly limitless number,
'diversity, and variety of combinations of rules to the user-
'defined subset of game rules. Afterward, the BIGS907 software
'application uses the three databases of player-finish
'probabilities, the three databases of dealer-finish
'probabilities, and the user-defined set of game rules, to find
'the set of combination-dependent-playing-strategy tables and
'to calculate the expected value of the game wager for an
'optional embodiment of the double-exposure game of the present
'invention that is subject to the user-defined set of game
'rules.

'The good news is. The BIGS987 software application enable
'users to load into program memory the set of databases of
'player-finish probabilities and the user-defined subset of
'game rules saved to a set of data files by the BIGS903
'software application. The BIGS987 software application enables
'users to load into program memory a corresponding set of
'databases of dealer-finish probabilities saved to a set of
'data files by the BIGS906 software application. The BIGS987
'software application enables users to complete the user-
'defined set of game rules by adding any of nearly limitless
'number, diversity, and variety of combinations of rules to the
'user-defined subset of game rules. Afterward, the BIGS987
'software application uses the three databases of player-finish
'probabilities, the three databases of dealer-finish
'probabilities, and the user-defined set of game rules, to find
'the set of combination-dependent-playing-strategy tables and
'to calculate the expected value of the game wager for an
'optional embodiment of the single-exposure game of the present
'invention that is subject to the user-defined set of game
'rules.

_TITLE "BIGS906 software application"
TYPE qbase
    dat0 AS SINGLE
    dat1 AS SINGLE
    dat2 AS SINGLE
    dat3 AS SINGLE
    dat4 AS SINGLE
    dat5 AS SINGLE
    dat6 AS SINGLE
    dat7 AS SINGLE
    dat8 AS SINGLE
    dat9 AS SINGLE
    dat10 AS SINGLE
    dat11 AS SINGLE
    dat12 AS SINGLE
    dat13 AS SINGLE
    dat14 AS SINGLE
END TYPE
DIM dfar(104, 104, 27, 14) AS SINGLE
DIM dsar(104, 104, 27, 14) AS SINGLE
DIM dbr(104, 104, 27, 14) AS SINGLE
DIM djoke(23) AS INTEGER
DIM dadd(23) AS INTEGER
DIM dp(23) AS SINGLE
DIM dmult(23) AS INTEGER
DIM database AS qbase
DIM mc(48): DIM mv(5) AS INTEGER
DIM df(27, 14) AS SINGLE: DIM card(28) AS INTEGER
DIM pc1 AS INTEGER: DIM pc2 AS INTEGER
DIM dc1 AS INTEGER: DIM dc2 AS INTEGER
GOTO 226
666 dmult(1) = (dc1 - 1) * (dc2 - 1)
dadd(1) = dc1 + dc2 - g
IF dadd(1) > -1 THEN df(I%, dadd(1)) = 1: GOTO 27
IF dmult(1) = 0 AND dadd(1) > k% THEN
    mv(1) = dadd(1) + 13
    df(I%, mv(1)) = 1
    GOTO 27
END IF
IF jo27% = 1 THEN
    djoke(2) = dc1 * dc2
    IF djoke(2) = 0 THEN
        df(I%, 27 - g) = 1
        GOTO 27
    END IF
END IF
FOR r = 0 TO 13 STEP 1
    dmult(3) = dmult(1) * (r - 1)
    dadd(3) = dadd(1) + r
    IF mc(r) < 1 THEN mc(16) = mc(r) ELSE mc(16) = 1
    IF mc(r) = 0 THEN GOTO 28
    dp(3) = mc(r) / mc(14)
    mc(r) = mc(r) - mc(16)
    mc(14) = mc(14) - mc(16)
    IF jo27% = 1 THEN
        djoke(3) = djoke(2) * r
        IF djoke(3) = 0 THEN
            df(I%, 27 - g) = df(I%, 27 - g) + dp(3)
            mc(r) = mc(r) + mc(16)
            mc(14) = mc(14) + mc(16)
            GOTO 28
        END IF
    END IF
    IF dadd(3) > -1 THEN
        df(I%, dadd(3)) = df(I%, dadd(3)) + dp(3)
        mc(r) = mc(r) + mc(16)
        mc(14) = mc(14) + mc(16)
        GOTO 28
    END IF
    IF dmult(3) = 0 AND dadd(3) > k% AND dadd(3) < j% THEN
        mv(1) = dadd(3) + 13
        df(I%, mv(1)) = df(I%, mv(1)) + dp(3)
        mc(r) = mc(r) + mc(16)
        mc(14) = mc(14) + mc(16)
        GOTO 28
    END IF
    FOR s = 0 TO 13 STEP 1
        dmult(4) = dmult(3) * (s - 1)
        dadd(4) = dadd(3) + s
        IF mc(s) < 1 THEN mc(17) = mc(s) ELSE mc(17) = 1
        IF mc(s) = 0 THEN GOTO 29
        dp(4) = dp(3) * mc(s) / mc(14)
        mc(s) = mc(s) - mc(17)
        mc(14) = mc(14) - mc(17)
        IF jo27% = 1 THEN
            djoke(4) = djoke(3) * s
            IF djoke(4) = 0 THEN
                df(I%, 27 - g) = df(I%, 27 - g) + dp(4)
                mc(s) = mc(s) + mc(17)
                mc(14) = mc(14) + mc(17)
                GOTO 29
            END IF
        END IF
        IF dadd(4) > -1 THEN
            df(I%, dadd(4)) = df(I%, dadd(4)) + dp(4)
            mc(s) = mc(s) + mc(17)
            mc(14) = mc(14) + mc(17)
            GOTO 29
        END IF
        IF dmult(4) = 0 AND dadd(4) > k% AND dadd(4) < j% THEN
            mv(1) = dadd(4) + 13
            df(I%, mv(1)) = df(I%, mv(1)) + dp(4)
            mc(s) = mc(s) + mc(17)
            mc(14) = mc(14) + mc(17)
            GOTO 29
        END IF
        FOR t = 0 TO 13 STEP 1
            dmult(5) = dmult(4) * (t - 1)
            dadd(5) = dadd(4) + t
            IF mc(t) < 1 THEN mc(18) = mc(t) ELSE mc(18) = 1
            IF mc(t) = 0 THEN GOTO 30
            dp(5) = dp(4) * mc(t) / mc(14)
            mc(t) = mc(t) - mc(18)
            mc(14) = mc(14) - mc(18)
            IF jo27% = 1 THEN
                djoke(5) = djoke(4) * t
                IF djoke(5) = 0 THEN
                    df(I%, 27 - g) = df(I%, 27 - g) + dp(5)
                    mc(t) = mc(t) + mc(18)
                    mc(14) = mc(14) + mc(18)
                    GOTO 30
                END IF
            END IF
            IF dadd(5) > -1 THEN
                df(I%, dadd(5)) = df(I%, dadd(5)) + dp(5)
                mc(t) = mc(t) + mc(18)
                mc(14) = mc(14) + mc(18)
                GOTO 30
            END IF
            IF dmult(5) = 0 AND dadd(5) > k% AND dadd(5) < j% THEN
                mv(1) = dadd(5) + 13
                df(I%, mv(1)) = df(I%, mv(1)) + dp(5)
                mc(t) = mc(t) + mc(18)
                mc(14) = mc(14) + mc(18)
                GOTO 30
            END IF
            FOR u = 0 TO 13 STEP 1
                dmult(6) = dmult(5) * (u - 1)
                dadd(6) = dadd(5) + u
                IF mc(u) < 1 THEN mc(19) = mc(u) ELSE mc(19) = 1
                IF mc(u) = 0 THEN GOTO 31
                dp(6) = dp(5) * mc(u) / mc(14)
                mc(u) = mc(u) - mc(19)
                mc(14) = mc(14) - mc(19)
                IF jo27% = 1 THEN
                    djoke(6) = djoke(5) * u
                    IF djoke(6) = 0 THEN
                        df(I%, 27 - g) = df(I%, 27 - g) + dp(6)
                        mc(u) = mc(u) + mc(19)
                        mc(14) = mc(14) + mc(19)
                        GOTO 31
                    END IF
                END IF
                IF dadd(6) > -1 THEN
                    df(I%, dadd(6)) = df(I%, dadd(6)) + dp(6)
                    mc(u) = mc(u) + mc(19)
                    mc(14) = mc(14) + mc(19)
                    GOTO 31
                END IF
                IF dmult(6) = 0 AND dadd(6) > k% AND dadd(6) < j% THEN
                    mv(1) = dadd(6) + 13
                    df(I%, mv(1)) = df(I%, mv(1)) + dp(6)
                    mc(u) = mc(u) + mc(19)
                    mc(14) = mc(14) + mc(19)
                    GOTO 31
                END IF
                FOR v = 0 TO 13 STEP 1
                    dmult(7) = dmult(6) * (v - 1)
                    dadd(7) = dadd(6) + v
                    IF mc(v) < 1 THEN mc(20) = mc(v) ELSE mc(20) = 1
                    IF mc(v) = 0 THEN GOTO 32
                    dp(7) = dp(6) * mc(v) / mc(14)
                    mc(v) = mc(v) - mc(20)
                    mc(14) = mc(14) - mc(20)
                    IF jo27% = 1 THEN
                        djoke(7) = djoke(6) * v
                        IF djoke(7) = 0 THEN
                            df(I%, 27 - g) = df(I%, 27 - g) + dp(7)
                            mc(v) = mc(v) + mc(20)
                            mc(14) = mc(14) + mc(20)
                            GOTO 32
                        END IF
                    END IF
                    IF dadd(7) > -1 THEN
                        df(I%, dadd(7)) = df(I%, dadd(7)) + dp(7)
                        mc(v) = mc(v) + mc(20)
                        mc(14) = mc(14) + mc(20)
                        GOTO 32
                    END IF
                    IF dmult(7) = 0 AND dadd(7) > k% AND dadd(7) < j% THEN
                        mv(1) = dadd(7) + 13
                        df(I%, mv(1)) = df(I%, mv(1)) + dp(7)
                        mc(v) = mc(v) + mc(20): mc(14) = mc(14) + mc(20)
                        GOTO 32
                    END IF
                    FOR w = 0 TO 13 STEP 1
                        dmult(8) = dmult(7) * (w - 1)
                        dadd(8) = dadd(7) + w
                        IF mc(w) < 1 THEN mc(15) = mc(w) ELSE mc(15) = 1
                        IF mc(w) = 0 THEN GOTO 33
                        dp(8) = dp(7) * mc(w) / mc(14)
                        mc(w) = mc(w) - mc(15)
                        mc(14) = mc(14) - mc(15)
                        IF jo27% = 1 THEN
                            djoke(8) = djoke(7) * w
                            IF djoke(8) = 0 THEN
                                df(I%, 27 - g) = df(I%, 27 - g) + dp(8)
                                mc(w) = mc(w) + mc(15)
                                mc(14) = mc(14) + mc(15)
                                GOTO 33
                            END IF
                        END IF
                        IF dadd(8) > -1 THEN
                            df(I%, dadd(8)) = df(I%, dadd(8)) + dp(8)
                            mc(w) = mc(w) + mc(15)
                            mc(14) = mc(14) + mc(15)
                            GOTO 33
                        END IF
                        IF dmult(8) = 0 AND dadd(8) > k% AND dadd(8) < j% THEN
                            mv(1) = dadd(8) + 13
                            df(I%, mv(1)) = df(I%, mv(1)) + dp(8)
                            mc(w) = mc(w) + mc(15)
                            mc(14) = mc(14) + mc(15)
                            GOTO 33
                        END IF
                        FOR o = 0 TO 13 STEP 1
                            dmult(9) = dmult(8) * (o - 1)
                            dadd(9) = dadd(8) + o
                            IF mc(o) < 1 THEN mc(21) = mc(o) ELSE mc(21) = 1
                            IF mc(o) = 0 THEN GOTO 34
                            dp(9) = dp(8) * mc(o) / mc(14)
                            mc(o) = mc(o) - mc(21)
                            mc(14) = mc(14) - mc(21)
                            IF jo27% = 1 THEN
                                djoke(9) = djoke(8) * o
                                IF djoke(9) = 0 THEN
                                    df(I%, 27 - g) = df(I%, 27 - g) + dp(9)
                                    mc(o) = mc(o) + mc(21)
                                    mc(14) = mc(14) + mc(21)
                                    GOTO 34
                                END IF
                            END IF
                            IF dadd(9) > -1 THEN
                                df(I%, dadd(9)) = df(I%, dadd(9)) + dp(9)
                                mc(o) = mc(o) + mc(21)
                                mc(14) = mc(14) + mc(21)
                                GOTO 34
                            END IF
                            IF dmult(9) = 0 AND dadd(9) > k% AND dadd(9) < j% THEN
                                mv(1) = dadd(9) + 13
                                df(I%, mv(1)) = df(I%, mv(1)) + dp(9)
                                mc(o) = mc(o) + mc(21): mc(14) = mc(14) + mc(21)
                                GOTO 34
                            END IF
                            mc(o) = mc(o) + mc(21)
                            mc(14) = mc(14) + mc(21)
                        34 NEXT o
                        mc(w) = mc(w) + mc(15)
                        mc(14) = mc(14) + mc(15)
                    33 NEXT w
                    mc(v) = mc(v) + mc(20)
                    mc(14) = mc(14) + mc(20)
                32 NEXT v
                mc(u) = mc(u) + mc(19)
                mc(14) = mc(14) + mc(19)
            31 NEXT u
            mc(t) = mc(t) + mc(18)
            mc(14) = mc(14) + mc(18)
        30 NEXT t
        mc(s) = mc(s) + mc(17)
        mc(14) = mc(14) + mc(17)
    29 NEXT s
    mc(r) = mc(r) + mc(16)
    mc(14) = mc(14) + mc(16)
28 NEXT r
27 FOR y = 0 TO 12
    df(I%, 13) = df(I%, 13) + df(I%, y)
NEXT y
FOR y = 0 TO 12
    df(I%, y) = df(I%, y) / df(I%, 13)
NEXT y
df(I%, 13) = 0
FOR y = 0 TO 12
    df(I%, 13) = df(I%, 13) + df(I%, y)
NEXT y
FOR y = 1 TO g - 15
    df(I%, 14) = df(I%, 14) + df(I%, 27 - g + y)
NEXT y
RETURN
226 CLS: PRINT "The BIGS906 software application ";
PRINT "enables the user to input into program memory"
PRINT "a subset of game rules. The subset of game ";
PRINT "rules specifies the number of decks"
PRINT "in a stack, and the composition of each ";
PRINT "deck. If the user-defined composition"
PRINT "of each deck includes at least one joker, ";
PRINT "then the subset of game rules"
PRINT "includes a rule that specifies the value ";
PRINT "assigned to each joker. The BIGS906"
PRINT "software application enables the user to ";
PRINT "select the rule from a group of rules"
PRINT "consisting of a rule that specifies each ";
PRINT "joker has a value of zero points, and"
PRINT "a rule that specifies each joker has a ";
PRINT "value of any number of points required"
PRINT "to make a hand total of twenty-seven ";
PRINT "points. Given the user-defined subset of"
PRINT "rules, the BIGS906 software application ";
PRINT "builds a set of databases of dealer-"
PRINT "finish probabilities. Subsequently, the ";
PRINT "BIGS906 software application saves the"
PRINT "set of databases of dealer-finish ";
PRINT "probabilities to a set of data files."
PRINT " "
' START OF THE SERIES OF PROMPTS FOR USER INPUT PROVIDED
' AS A SOFTWARE MEANS FOR MAKING A SUBSET OF RULES.

PRINT "press 'y' and enter for a standard deck composition"
INPUT ans$
PRINT " "
IF ans$ = "y" THEN
    FOR x = 1 TO 13
    card(x) = 4: NEXT x: card(0) = 2: card(14) = 54
END IF
IF ans$ <> "y" THEN
    PRINT "enter deck composition "
    PRINT " "
    FOR x = 0 TO 13
        IF x = 1 THEN
            PRINT "input the number of cards ";
            PRINT "assigned a value "
            PRINT "selected from a group ";
            PRINT "consisting of 1 point and 14 points."
            INPUT a
            PRINT " "
            card(1) = a
            card(14) = card(14) + a
        END IF
        IF x <> 1 THEN
            PRINT "input the number of cards ";
            PRINT "assigned a value";
            PRINT " of "; x; " points."
            INPUT a
            PRINT " "
            card(x) = a
            card(14) = card(14) + a
        END IF
    NEXT x
END IF
IF card(0) = 0 THEN
    PRINT "input the number of cards assigned a value ";
    PRINT "selected from a group consisting "
    PRINT "of any number of points required to bring ";
    PRINT "the sum of the point values"
    PRINT "assigned to the cards ";
    PRINT "in a hand to twenty-seven points."
    INPUT a
    PRINT " "
    card(0) = a
    card(14) = card(14) + a
    jo27% = 1
    PRINT " "
END IF
PRINT "input the number decks of cards"
INPUT deck%
PRINT " "

' END OF THE SERIES OF PROMPTS FOR USER INPUT PROVIDED
' AS A SOFTWARE MEANS FOR MAKING A SUBSET OF RULES.

999 PRINT "enter the 'folder/filename prefix' of"
PRINT "the files to be used to store application output."
INPUT files$
PRINT " "
OPEN files$ + "i.txt" FOR OUTPUT AS #1
PRINT #1, "BIGS906.BAS builds databases of ";
PRINT #1, "dealer finish probabilities"
PRINT #1, "for various optional embodiments ";
PRINT #1, "of the game of the present"
PRINT #1, "invention and saves the databases to a set of files."
PRINT #1, " "
PRINT #1, "BIGS906 PROMPTS FOR INPUT AND USER RESPONSES"
PRINT #1, " "
PRINT #1, "press 'y' and enter for a standard deck composition "
PRINT #1, ans$
PRINT #1, " "
IF ans$ <> "y" THEN
    PRINT #1, "enter deck composition "
    PRINT #1, " "
END IF
FOR x = 0 TO 13
    IF x = 1 THEN
        PRINT #1, "input the number of cards ";
        PRINT #1, "assigned a value "
        PRINT #1, "selected from a group ";
        PRINT #1, "consisting of 1 point and 14 points."
        PRINT #1, card(1)
        PRINT #1, " "
    END IF
    IF x <> 1 THEN
        PRINT #1, "input the number of cards ";
        PRINT #1, "assigned a value";
        PRINT #1, " of "; x; " points."
        IF jo27% <> 1 OR x <> 0 THEN
            PRINT #1, card(x)
        END IF
        IF jo27% = 1 AND x = 0 THEN
            PRINT #1, " 0"
        END IF
        PRINT #1, " "
    END IF
NEXT x
IF jo27% = 1 THEN
    PRINT #1, "input the number of cards assigned a value ";
    PRINT #1, "selected from a group consisting "
    PRINT #1, "of any number of points required to bring ";
    PRINT #1, "the sum of the point values"
    PRINT #1, "assigned to the cards ";
    PRINT #1, "in a hand to twenty-seven points."
    PRINT #1, card(0)
    PRINT #1, " "
END IF
PRINT #1, "input the number of decks used"
PRINT #1, deck%
PRINT #1, " "
PRINT #1, "enter the 'folder/filename prefix' of"
PRINT #1, "the files to be used to store application output."
PRINT #1, files$
PRINT #1, " "
PRINT #1, " "
PRINT #1, "START: "; DATE$; " "; TIME$
CLOSE #1
FOR k = 13 TO 0 STEP -1
    FOR l = 13 TO k STEP -1
        FOR m = 13 TO 0 STEP -1
            FOR e = 13 TO m STEP -1
                pc1 = k: pc2 = l: dc1 = m: dc2 = e: I% = 0
                pn% = pc1 / 2 * (27 - pc1) + pc2
                dn% = dc1 / 2 * (27 - dc1) + dc2
                FOR g = 19 TO 24
                    FOR h = 5 TO 11
                        IF h + 14 < g THEN h = g - 14
                        IF g = 19 AND h = 5 THEN I% = 0
                        I% = I% + 1: j% = 15 - g: k% = h - g
                        FOR x = 0 TO 14
                        mc(x) = card(x) * deck%: NEXT x
                        IF mc(pc1) < 1 THEN mc(22) = mc(pc1) ELSE mc(22) = 1
                        IF mc(pc1) = 0 THEN GOTO 456
                        mc(pc1) = mc(pc1) - mc(22)
                        mc(14) = mc(14) - mc(22)
                        IF mc(pc2) < 1 THEN mc(22) = mc(pc2) ELSE mc(22) = 1
                        IF mc(pc2) = 0 THEN GOTO 456
                        mc(pc2) = mc(pc2) - mc(22)
                        mc(14) = mc(14) - mc(22)
                        IF mc(dc1) < 1 THEN mc(22) = mc(dc1) ELSE mc(22) = 1
                        IF mc(dc1) = 0 THEN GOTO 456
                        mc(dc1) = mc(dc1) - mc(22)
                        mc(14) = mc(14) - mc(22)
                        IF mc(dc2) < 1 THEN mc(22) = mc(dc2) ELSE mc(22) = 1
                        IF mc(dc2) = 0 THEN GOTO 456
                        mc(dc2) = mc(dc2) - mc(22)
                        mc(14) = mc(14) - mc(22)
                        GOSUB 666
                NEXT h: NEXT g
                FOR x = 0 TO 27
                    FOR y = 0 TO 14
                        dbr(pn%, dn%, x, y) = df(x, y)
                NEXT y: NEXT x
                ERASE df
                IF pc1 <> pc2 THEN GOTO 333
                FOR pc2 = 13 TO 0 STEP -1
                    IF pc1 <= pc2 THEN pn% = pc1 / 2 * (27 - pc1) + pc2
                    IF pc1 > pc2 THEN pn% = pc2 / 2 * (27 - pc2) + pc1
                    FOR g = 19 TO 24
                        FOR h = 5 TO 11
                            IF h + 14 < g THEN h = g - 14
                            IF g = 19 AND h = 5 THEN I% = 0
                            I% = I% + 1: j% = 15 - g: k% = h - g
                            FOR x = 0 TO 14
                            mc(x) = card(x) * deck%: NEXT x
                            IF mc(pc1) < 1 THEN mc(22) = mc(pc1) ELSE mc(22) = 1
                            IF mc(pc1) = 0 THEN GOTO 444
                            mc(pc1) = mc(pc1) - mc(22)
                            mc(14) = mc(14) - mc(22)
                            IF mc(pc1) < 1 THEN mc(22) = mc(pc1) ELSE mc(22) = 1
                            IF mc(pc1) = 0 THEN GOTO 444
                            mc(pc1) = mc(pc1) - mc(22)
                            mc(14) = mc(14) - mc(22)
                            IF mc(pc2) < 1 THEN mc(22) = mc(pc2) ELSE mc(22) = 1
                            IF mc(pc2) = 0 THEN GOTO 444
                            mc(pc2) = mc(pc2) - mc(22)
                            mc(14) = mc(14) - mc(22)
                            IF mc(dc1) < 1 THEN mc(22) = mc(dc1) ELSE mc(22) = 1
                            IF mc(dc1) = 0 THEN GOTO 444
                            mc(dc1) = mc(dc1) - mc(22)
                            mc(14) = mc(14) - mc(22)
                            IF mc(dc2) < 1 THEN mc(22) = mc(dc2) ELSE mc(22) = 1
                            IF mc(dc2) = 0 THEN GOTO 444 ELSE
                            mc(dc2) = mc(dc2) - mc(22)
                            mc(14) = mc(14) - mc(22)
                            GOSUB 666
                    NEXT h: NEXT g
                    IF pc1 > pc2 THEN
                        FOR x = 0 TO 27
                            FOR y = 0 TO 14
                                dfar(pn%, dn%, x, y) = df(x, y)
                        NEXT y: NEXT x
                    END IF
                    IF pc1 = pc2 THEN
                        FOR x = 0 TO 27
                            FOR y = 0 TO 14
                                dfar(pn%, dn%, x, y) = df(x, y)
                                dsar(pn%, dn%, x, y) = df(x, y)
                        NEXT y: NEXT x
                    END IF
                    IF pc1 < pc2 THEN
                        FOR x = 0 TO 27
                            FOR y = 0 TO 14
                                dsar(pn%, dn%, x, y) = df(x, y)
                        NEXT y: NEXT x
                    END IF
                    ERASE df
                444 NEXT pc2
                pc2 = pc1
                pn% = pc1 / 2 * (27 - pc1) + pc2
                333 PRINT "           player cards are"; pc1; "and"; pc2;
                PRINT "dealer cards are"; dc1; "and"; dc2
456 NEXT e: NEXT m: NEXT l: NEXT k
v$ = files$ + "e.dat"
w = 0
OPEN v$ FOR RANDOM AS #1 LEN = LEN(database)
FOR x = 0 TO 6
    FOR y = 0 TO 104
        FOR r = 0 TO 27
            FOR f = 0 TO 14
                w = w + 1
                database.dat0 = dbr(x * 15 + 0, y, r, f)
                database.dat1 = dbr(x * 15 + 1, y, r, f)
                database.dat2 = dbr(x * 15 + 2, y, r, f)
                database.dat3 = dbr(x * 15 + 3, y, r, f)
                database.dat4 = dbr(x * 15 + 4, y, r, f)
                database.dat5 = dbr(x * 15 + 5, y, r, f)
                database.dat6 = dbr(x * 15 + 6, y, r, f)
                database.dat7 = dbr(x * 15 + 7, y, r, f)
                database.dat8 = dbr(x * 15 + 8, y, r, f)
                database.dat9 = dbr(x * 15 + 9, y, r, f)
                database.dat10 = dbr(x * 15 + 10, y, r, f)
                database.dat11 = dbr(x * 15 + 11, y, r, f)
                database.dat12 = dbr(x * 15 + 12, y, r, f)
                database.dat13 = dbr(x * 15 + 13, y, r, f)
                database.dat14 = dbr(x * 15 + 14, y, r, f)
                PUT #1, w, database
            NEXT f
        NEXT r
    NEXT y
NEXT x
CLOSE #1
v$ = files$ + "f.dat"
w = 0
OPEN v$ FOR RANDOM AS #1 LEN = LEN(database)
FOR x = 0 TO 6
    FOR y = 0 TO 104
        FOR r = 0 TO 27
            FOR f = 0 TO 14
                w = w + 1
                database.dat0 = dfar(x * 15 + 0, y, r, f)
                database.dat1 = dfar(x * 15 + 1, y, r, f)
                database.dat2 = dfar(x * 15 + 2, y, r, f)
                database.dat3 = dfar(x * 15 + 3, y, r, f)
                database.dat4 = dfar(x * 15 + 4, y, r, f)
                database.dat5 = dfar(x * 15 + 5, y, r, f)
                database.dat6 = dfar(x * 15 + 6, y, r, f)
                database.dat7 = dfar(x * 15 + 7, y, r, f)
                database.dat8 = dfar(x * 15 + 8, y, r, f)
                database.dat9 = dfar(x * 15 + 9, y, r, f)
                database.dat10 = dfar(x * 15 + 10, y, r, f)
                database.dat11 = dfar(x * 15 + 11, y, r, f)
                database.dat12 = dfar(x * 15 + 12, y, r, f)
                database.dat13 = dfar(x * 15 + 13, y, r, f)
                database.dat14 = dfar(x * 15 + 14, y, r, f)
                PUT #1, w, database
            NEXT f
        NEXT r
    NEXT y
NEXT x
CLOSE #1
v$ = files$ + "g.dat"
w = 0
OPEN v$ FOR RANDOM AS #1 LEN = LEN(database)
FOR x = 0 TO 6
    FOR y = 0 TO 104
        FOR r = 0 TO 27
            FOR f = 0 TO 14
                w = w + 1
                database.dat0 = dsar(x * 15 + 0, y, r, f)
                database.dat1 = dsar(x * 15 + 1, y, r, f)
                database.dat2 = dsar(x * 15 + 2, y, r, f)
                database.dat3 = dsar(x * 15 + 3, y, r, f)
                database.dat4 = dsar(x * 15 + 4, y, r, f)
                database.dat5 = dsar(x * 15 + 5, y, r, f)
                database.dat6 = dsar(x * 15 + 6, y, r, f)
                database.dat7 = dsar(x * 15 + 7, y, r, f)
                database.dat8 = dsar(x * 15 + 8, y, r, f)
                database.dat9 = dsar(x * 15 + 9, y, r, f)
                database.dat10 = dsar(x * 15 + 10, y, r, f)
                database.dat11 = dsar(x * 15 + 11, y, r, f)
                database.dat12 = dsar(x * 15 + 12, y, r, f)
                database.dat13 = dsar(x * 15 + 13, y, r, f)
                database.dat14 = dsar(x * 15 + 14, y, r, f)
                PUT #1, w, database
            NEXT f
        NEXT r
    NEXT y
NEXT x
CLOSE #1
OPEN files$ + "i.txt" FOR APPEND AS #1
PRINT #1, ""
PRINT #1, "END:   "; DATE$; " "; TIME$
CLOSE #1
END


